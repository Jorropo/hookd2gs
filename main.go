package main

import (
	"bufio"
	"flag"
	"io"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/reiver/go-telnet"
)

var (
	HostFlag         = flag.String("host", "localhost:8888", "address of d2gs telnet daemon")
	Host             string
	PasswordFlag     = flag.String("p", "", "d2gs admin password (for telnet)")
	Password         string
	PasswordFileFlag = flag.String("pf", "", "path to file containing d2gs admin password (for telnet)")
	PasswordFile     string
)

// TODO don't rely on bash
func runCommand(command string) (stdout, stderr io.ReadCloser, done chan bool) {
	var err error
	done = make(chan bool, 1)
	cmd := exec.Command("bash", "-c", command)
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Setpgid: true,
	}
	stdout, err = cmd.StdoutPipe()
	if err != nil {
		done <- true
		log.Fatalln("Error: ", command, err)
		return
	}
	stderr, err = cmd.StderrPipe()
	if err != nil {
		done <- true
		log.Fatalln("Error: ", command, err)
		return
	}
	if err := cmd.Start(); err != nil {
		done <- true
		log.Fatalln("Error: ", command, err)
		return
	}

	go func() {
		if err := cmd.Wait(); err != nil {
			done <- true
			log.Println("Error: ", command, err)
			return
		}
		done <- true
	}()

	return
}

// I was having trouble getting the telnet lib to cooperate with the stdlib utils so I made this janky function
func readTelnetLine(reader io.Reader) string {
	lineb := make([]byte, 0)
	oneByte := make([]byte, 1)
	for oneByte[0] != '\n' {
		reader.Read(oneByte)
		lineb = append(lineb, oneByte[0])
	}
	return string(lineb)
}

// triggered by sendRestartSignal
func dieEarly() {
	const CURRENT_USERS_IN_GAME = "Current users in game: "

	conn, err := telnet.DialTo(Host)
	if err != nil {
		log.Fatalln(err)
	}
	conn.Write([]byte(Password + "\n"))
	time.Sleep(time.Millisecond * 200)
	users := 1
	for users > 0 {
		conn.Write([]byte("status\n"))
		for {
			line := readTelnetLine(conn)
			if strings.HasPrefix(line, CURRENT_USERS_IN_GAME) {
				userc, err := strconv.Atoi(line[len(CURRENT_USERS_IN_GAME) : len(line)-2])
				if err != nil {
					log.Println(err)
				} else {
					log.Println("[DEBUG] Users online:", userc)
					users = userc
					break
				}
			}
		}
		time.Sleep(time.Second * 3)
	}
	log.Println("[DEBUG] No users online, rebooting early.")
	conn.Write([]byte("restart 1\n"))
	time.Sleep(time.Millisecond * 200)
	conn.Close()
	time.Sleep(time.Second * 7)
}

func sendRestartSignal(fail bool) {
	conn, err := telnet.DialTo(Host)
	if err != nil {
		log.Fatalln(err)
	}
	conn.Write([]byte(Password + "\n"))
	time.Sleep(time.Second)
	if fail {
		log.Println("Restarting d2gs due to error.")
		conn.Write([]byte(`msg sys #all "[server] I have encountered an error which is preventing people from creating new games."` + "\n"))
	} else {
		log.Println("Restarting d2gs as instructed.")
		conn.Write([]byte(`msg sys #all "[server] I've been ordered to restart, so I must do so."` + "\n"))
	}
	time.Sleep(time.Millisecond * 200)
	conn.Write([]byte(`msg sys #all "[server] I will restart in 5mins, so please save and quit at your earliest convenience,"` + "\n"))
	time.Sleep(time.Millisecond * 200)
	conn.Write([]byte(`msg sys #all "[server] and rejoin after the restart :)"` + "\n"))
	time.Sleep(time.Millisecond * 200)
	conn.Write([]byte("restart 300\n"))

	conn.Close()
	go dieEarly() // watch if all players leave, then restart immediately
}

// readPipe reads a pipe generated by a command, and exits when the pipe closes. Intercepts errors, restarts the daemon when they occur.
func readPipe(pipe io.ReadCloser) {
	var err error
	var dead bool
	out := bufio.NewReader(pipe)
	for err == nil {
		var line string
		line, err = out.ReadString('\n')
		log.Printf("%s", line)
		if !dead && strings.HasPrefix(line, "err") {
			dead = true
			sendRestartSignal(true)
		}
	}
}

func main() {
	// Process config and flags.
	flag.Parse()
	Host = *HostFlag
	Password = *PasswordFlag
	PasswordFile = *PasswordFileFlag

	if Password == ""  && PasswordFile == "" {
		log.Println("Either -p or -pf must be set.")
		flag.PrintDefaults()
		return
	} else if PasswordFile != "" {
		pws, err := os.ReadFile(PasswordFile)
		if err != nil {
			log.Println("Error loading password file:", err)
			return
		}
		Password = string(pws)
	}

	var dead bool

	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP, syscall.SIGQUIT)
	go func() {
		<-sigs
		dead = true
		sendRestartSignal(false)
	}()

	for !dead {
		stdout, stderr, done := runCommand("wine D2GS.exe")
		go readPipe(stdout)
		go readPipe(stderr)
		<-done
		time.Sleep(time.Second * 1)
	}

	os.Exit(0)
}
